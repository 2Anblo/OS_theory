1、存储层次
	寄存器（速度快）->快速缓存->内存->外存（非易失，容量大）

2、内存分区（分区存储管理）
	最早不分区，整个地址为连续空间，由CPU的PC生成地址。	

固定分区：（有内碎片）
	等额固定分区：分区大小全部相同
	差额固定分区：大程序用大分区，小程序用小分区（管理复杂）
	优点：简单、易于实现、开销小
	缺点：内碎片造成浪费。
		 分区总数固定，限制并发程序数目。
动态分区：（外碎片）
	按需分配分区空间大小。
	优点：基本没有内碎片。
	缺点：有外碎片。
	使用内存紧缩方法，将小碎片收集成大区域，装载进入内存。

内存重定位/地址映射：（逻辑地址->物理地址）
	静态重定位：
	在（用户exe）程序装入之前内存，通过查询程序代码中的重定位表（Relocation Table）改写程序内要跳转的地址，（由软件OS逐个计算）先计算好。
	动态重定位：
	使用base寄存器和limit寄存器。
	基址寄存器用于重定位，来做物理地址映射。
	界限寄存器来做内存保护，防止越界。
	以JMP 28为例，将28与基址寄存器内存放的地址直接相加，得到要跳转的地址。
	将28与limit寄存器内存放的数比较，以判断JMP跳转地址是否合法。
内外存交换：
	以进程为单位（整个进程换入换出），将进程阻塞挂起，暂存在硬盘/交换区/文件中。
	进程内增长空间的堆栈段/数据段可以互相交换。
内存组织管理：
	用位示图表示内存管理，占内存，开销大。
	用链表表示内存管理信息。
分配内存的算法：
	First Fit 最先适应算法（从0开始遍历Hole碎片结点，选择最先能放下的）——偏好内存低端地址，容易造成低端地址故障。
	Next Fit 下次适应算法 （从当前指针位置开始遍历，找到下一次能放下的）——效果最好
	Best Fit 最佳适应算法（遍历全部Hole结点，找到大小最接近的）
	Worst Fit 最差适应算法（找到最大的）


3、虚拟内存
虚拟存储：1、部分装入程序
		2、地址不连续
分页：把程序分成固定大小的页面。（将进程部分装入内存）
页框：将物理内存切块。
页表：指出页面和页框之间的映射关系。
虚拟存储的基本原理：
	只需要将当前需要执行的部分（页/段）读入到内存——部分装入（局部性原理）
	由处理器通知操作系统将相应的部分（页/段）调入到内存（缺页中断技术，MMU机制）
局部性原理
	1、时间局部性——顺序执行
	2、空间局部性——循环执行
页面Page（页面数>页框数）：一般4KB一个Page，存放页框号做基址，所以程序装入物理内存中地址不连续，离散存放。
优点：没有外碎片，每个内碎片不超过页大小。一个进程基本只有一个页有内碎片。

MMU（Memory Management Unit）：接受PC和页表，通过地址加法器将偏移量和base寄存器的值相加。
典型虚拟页表表项的构成：20bit的页框号+12bit的标志位（dirty,modified位,R/W/Exe位,Present/Absent位）
页表被用于将页面号指向页框号。

虚拟存储技术的特征：
	离散性：装入的进程离散存放。
	多次性：一个进程多次装载。（部分装入）
	对换性：部分交换（以页面为单位交换，不会挂起）
	虚拟性：大空间。

TLB (Translation Lookaside Buffers) 关联存储器 快表
虚拟地址的高位页面号，先访问TLB，若未命中，再访问内存，并把表项刷新进TLB，若内存中找不到，则进行缺页中断处理。

一个进程对应一个页表。
32位单级页表，每个页表占用4MB（20位地址,用4字节（4B）存储），进程多开销大。
二级页表可以部分装入内存。
页面大小等于2^页内偏移量的位数。
二级页表的访存次数：
	第一次访存：访问内存中的页目录表（一级页表，去找到二级页表在内存中的地址）
	第二次访存：访问内存中的二级页表（找到目标内存单元在内存中的地址）
	第三次访存：访问目标内存单元

4、页面置换算法
The Optimal Page Replacement Algorithm 最佳置换算法
	淘汰离当前最远的页面。（看未来）
NRU(Not Recently Used) 最近未使用算法
	设置有Referenced（访问）位,Modified（修改）位。
	置换顺序：
	1. R = 0, M = 0
	2. R = 0, M = 1
	3. R = 1, M = 0
	4. R = 1, M = 1
	如果有Modified的话，需要在被换出内存之前写回磁盘以保证数据的一致性。
FIFO 先进先出
	Belady异常（只出现在FIFO中）
	分的页框越多缺页率越高 -> 未考虑局部性原理。
Second Chance 二次命中/机会法 （NRU+FIFO）
	记录每个表项的加载（loaded）时间，淘汰时看Referenced位，挑时间最早的R置0，放到队尾刷新loaded时间。
Clock 时钟算法
	二次命中法，用循环数组实现。
LRU(Last Recently Used) 最近最久未使用算法
	最接近最佳置换算法。
	软件模拟LRU：（Aging 老化算法）
		每个时钟周期为每个页面置位，右移，挑选最小的淘汰。
Working Set 工作集算法 （根据局部性原理） 系统开销大
	分为请求式调页（第一次调入内存）和预调页（假设把原本调出的页面调回）。
	设定阈值，选择常用工作集，将Working Set驻留内存。
WSClock 工作集时钟算法
	老化时间 = 当前时间 - 进内存的时间（loaded time）

5、页式存储管理分析
	局部置换策略和全局置换策略
	局部置换：
		每个进程的页面数量不变。
		实现简单。
	全局置换：
		全局置换，可能会将其他进程页面置换出去。
		影响每个进程的页面数目。
		性能优越。
	交换/中级调度的负载控制（通过控制缺页率来控制负载）
	分配的页框数目少时：
		出现频繁地换入换出，内存抖动现象。
	将缺页率控制在合理的范围内：
		当缺页率居高不下时，应减少程序运行的并发度/增加物理内存大小。
	页面尺寸的选择：
	页面小：
		内碎片少。
		页表大，内存开销大。
	通过内存的开销函数求出极值，一般为4KB或者8KB
	分开指令空间和数据空间，可以让两个不同进程的页表指向同一个页框。
	
6、页式存储管理实现
	请求分页系统中的外存分为两部分：
	用于存放文件的文件区：
		第一次调入
	用于存放对换页面的对换区：
		换出后再换入（存放在对换区和存放在内存相似）

7、分段
	从用户角度出发，给程序分段（代码段，堆栈段....）
段页式页表表项：
	段描述子+段内分页+页内偏移量
	三次访存，二维地址
	
